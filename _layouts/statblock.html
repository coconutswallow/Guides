---
layout: default
---

<div class="export-button-container">
    <button class="export-json-button" onclick="exportToJSON()">Download JSON</button>
</div>

{{ content }}

{% if page.creator %}
<div class="statblock-creator">
    <strong>Creator:</strong> {{ page.creator }}
</div>
{% endif %}

{% if page.image %}
<div class="monster-image-container">
    <img src="{{ page.image | relative_url }}" alt="{{ page.title }}">
    {% if page.image_credit %}
    <p class="image-credit">{{ page.image_credit }}</p>
    {% endif %}
</div>
{% endif %}

<!-- JSON Export Script -->
<script>
function exportToJSON() {
    // Extract data from the page
    const pageData = {
        title: "{{ page.title | escape }}",
        size: "{{ page.size }}",
        type: "{{ page.type }}",
        alignment: "{{ page.alignment }}",
        cr: "{{ page.cr }}",
        creator: "{{ page.creator }}"
    };
    
    // Parse the stat block content
    const statBlock = document.querySelector('blockquote');
    if (!statBlock) {
        alert('Could not find stat block to export!');
        return;
    }
    
    // Create JSON structure based on the 5etools format
    const jsonData = {
        "siteVersion": "1.197.0",
        "_meta": {
            "sources": [
                {
                    "json": "HawthorneFieldGuide",
                    "abbreviation": "HFG",
                    "full": "Hawthorne Field Guide",
                    "url": "",
                    "authors": [pageData.creator || ""],
                    "convertedBy": []
                }
            ],
            "dateAdded": Math.floor(Date.now() / 1000),
            "dateLastModified": Math.floor(Date.now() / 1000)
        },
        "monster": [
            parseStatBlock(statBlock, pageData)
        ]
    };
    
    // Download the JSON file
    const jsonString = JSON.stringify(jsonData, null, '\t');
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = pageData.title.replace(/\s+/g, '_') + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function parseStatBlock(statBlock, pageData) {
    const monster = {
        "name": pageData.title,
        "source": "HawthorneFieldGuide",
        "page": 1
    };
    
    // Parse size
    const sizeMap = {
        'Tiny': 'T', 'Small': 'S', 'Medium': 'M',
        'Large': 'L', 'Huge': 'H', 'Gargantuan': 'G'
    };
    monster.size = [sizeMap[pageData.size] || 'M'];
    
    // Parse type
    monster.type = pageData.type.toLowerCase();
    
    // Parse alignment
    const alignmentText = pageData.alignment.toLowerCase();
    if (alignmentText.includes('chaotic') && alignmentText.includes('neutral')) {
        monster.alignment = ['C', 'N'];
    } else if (alignmentText.includes('lawful') && alignmentText.includes('good')) {
        monster.alignment = ['L', 'G'];
    } else if (alignmentText.includes('neutral') && alignmentText.includes('good')) {
        monster.alignment = ['N', 'G'];
    } else if (alignmentText.includes('chaotic') && alignmentText.includes('good')) {
        monster.alignment = ['C', 'G'];
    } else if (alignmentText.includes('lawful') && alignmentText.includes('evil')) {
        monster.alignment = ['L', 'E'];
    } else if (alignmentText.includes('neutral') && alignmentText.includes('evil')) {
        monster.alignment = ['N', 'E'];
    } else if (alignmentText.includes('chaotic') && alignmentText.includes('evil')) {
        monster.alignment = ['C', 'E'];
    } else if (alignmentText.includes('lawful') && alignmentText.includes('neutral')) {
        monster.alignment = ['L', 'N'];
    } else if (alignmentText.includes('true neutral') || alignmentText === 'neutral') {
        monster.alignment = ['N'];
    } else {
        monster.alignment = ['N'];
    }
    
    // Get all paragraphs from stat block
    const paragraphs = statBlock.querySelectorAll('p');
    
    // Parse AC, HP, Speed from first few paragraphs
    paragraphs.forEach((p, index) => {
        const text = p.textContent;
        
        // AC
        if (text.includes('AC ')) {
            const acMatch = text.match(/AC\s+(\d+)/);
            if (acMatch) {
                monster.ac = [{ "ac": parseInt(acMatch[1]), "from": ["natural armor"] }];
            }
        }
        
        // HP
        if (text.includes('HP ')) {
            const hpMatch = text.match(/HP\s+(\d+)\s+\(([^)]+)\)/);
            if (hpMatch) {
                monster.hp = {
                    "average": parseInt(hpMatch[1]),
                    "formula": hpMatch[2]
                };
            }
        }
        
        // Speed
        if (text.includes('Speed ')) {
            const speedText = text.substring(text.indexOf('Speed ') + 6);
            monster.speed = parseSpeed(speedText);
        }
    });
    
    // Parse ability scores from table
    const table = statBlock.querySelector('table');
    if (table) {
        const cells = table.querySelectorAll('td');
        const abilities = [];
        
        for (let i = 0; i < cells.length; i += 4) {
            const abilityName = cells[i].textContent.trim().toLowerCase();
            const score = parseInt(cells[i + 1].textContent.trim());
            const save = cells[i + 3].textContent.trim();
            
            abilities.push({ name: abilityName, score: score, save: save });
        }
        
        abilities.forEach(ability => {
            switch(ability.name) {
                case 'str': monster.str = ability.score; break;
                case 'dex': monster.dex = ability.score; break;
                case 'con': monster.con = ability.score; break;
                case 'int': monster.int = ability.score; break;
                case 'wis': monster.wis = ability.score; break;
                case 'cha': monster.cha = ability.score; break;
            }
        });
        
        // Saves
        monster.save = {};
        abilities.forEach(ability => {
            if (ability.save && ability.save !== 'â€”' && ability.save !== '-') {
                monster.save[ability.name] = ability.save;
            }
        });
    }
    
    // Parse other properties from paragraphs
    paragraphs.forEach(p => {
        const text = p.textContent;
        const strongText = p.querySelector('strong')?.textContent || '';
        
        if (strongText.includes('Skills')) {
            monster.skill = parseSkills(text);
        }
        if (strongText.includes('Damage Immunities') || strongText.includes('Immunities')) {
            monster.immune = text.replace(/.*Immunities\s+/, '').split(',').map(s => s.trim().toLowerCase());
        }
        if (strongText.includes('Condition Immunities')) {
            monster.conditionImmune = text.replace(/.*Condition Immunities\s+/, '').split(',').map(s => s.trim().toLowerCase());
        }
        if (strongText.includes('Senses')) {
            monster.senses = parseSenses(text);
            const passiveMatch = text.match(/Passive Perception\s+(\d+)/i);
            if (passiveMatch) {
                monster.passive = parseInt(passiveMatch[1]);
            }
        }
        if (strongText.includes('Languages')) {
            monster.languages = text.replace(/.*Languages\s+/, '').split(',').map(s => s.trim());
        }
        if (strongText.includes('CR ')) {
            const crMatch = text.match(/CR\s+([\d\/]+)/);
            if (crMatch) {
                monster.cr = crMatch[1];
            }
        }
    });
    
    // Parse traits, actions, legendary actions
    monster.trait = [];
    monster.action = [];
    monster.legendary = [];
    
    let currentSection = null;
    const sections = statBlock.querySelectorAll('h3, p');
    
    sections.forEach(element => {
        if (element.tagName === 'H3') {
            const sectionName = element.textContent.trim().toUpperCase();
            if (sectionName.includes('TRAIT')) currentSection = 'trait';
            else if (sectionName.includes('ACTION')) currentSection = 'action';
            else if (sectionName.includes('LEGENDARY')) currentSection = 'legendary';
        } else if (element.tagName === 'P' && currentSection) {
            const strong = element.querySelector('strong');
            if (strong) {
                const name = strong.textContent.replace(/\.$/, '').trim();
                const description = element.textContent.substring(strong.textContent.length).trim();
                
                const entry = {
                    "name": name,
                    "entries": [description]
                };
                
                monster[currentSection].push(entry);
            }
        }
    });
    
    return monster;
}

function parseSpeed(speedText) {
    const speed = {};
    const parts = speedText.split(',');
    
    parts.forEach(part => {
        part = part.trim();
        if (part.includes('fly')) {
            const match = part.match(/(\d+)\s*ft/);
            if (match) {
                speed.fly = {
                    "number": parseInt(match[1]),
                    "condition": part.includes('hover') ? '(hover)' : undefined
                };
                if (part.includes('hover')) {
                    speed.canHover = true;
                }
            }
        } else if (part.includes('swim')) {
            const match = part.match(/(\d+)\s*ft/);
            if (match) speed.swim = parseInt(match[1]);
        } else if (part.includes('climb')) {
            const match = part.match(/(\d+)\s*ft/);
            if (match) speed.climb = parseInt(match[1]);
        } else {
            const match = part.match(/(\d+)\s*ft/);
            if (match) speed.walk = parseInt(match[1]);
        }
    });
    
    return speed;
}

function parseSkills(text) {
    const skills = {};
    const skillText = text.replace(/.*Skills\s+/, '');
    const skillParts = skillText.split(',');
    
    skillParts.forEach(part => {
        const match = part.trim().match(/([A-Za-z\s]+)\s+([+\-]\d+)/);
        if (match) {
            const skillName = match[1].trim().toLowerCase();
            skills[skillName] = match[2];
        }
    });
    
    return skills;
}

function parseSenses(text) {
    const senses = [];
    const senseText = text.replace(/.*Senses\s+/, '').replace(/Passive Perception.*/, '').trim();
    const senseParts = senseText.split(',');
    
    senseParts.forEach(part => {
        const sense = part.trim();
        if (sense && !sense.toLowerCase().includes('passive')) {
            senses.push(sense);
        }
    });
    
    return senses;
}
</script>