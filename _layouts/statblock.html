---
layout: default
body_class: monster-page
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<style>
    /* Grid container for the top stats line */
    .stat-grid-container {
        display: grid;
        /* "max-content" makes the columns only as wide as the text inside them */
        grid-template-columns: max-content max-content; 
        /* Aligns the columns to the left (start) */
        justify-content: start;
        /* Adds the requested spacing (approx 4 tabs width) */
        column-gap: 8em; 
        row-gap: 2px;
        margin-bottom: 1em;
    }

    /* Individual cells */
    .stat-cell-ac { grid-column: 1; }
    
    .stat-cell-init { 
        grid-column: 2; 
        text-align: left; 
    }
    
    .stat-cell-hp { grid-column: 1 / -1; } /* Spans full width */
    .stat-cell-speed { grid-column: 1 / -1; } /* Spans full width */
    
    /* Ensure bold headers look correct */
    .stat-grid-container strong, .stat-grid-container b {
        font-weight: bold;
        color: #7a200d; 
    }
</style>

{% if page.creator %}
<p class="creator-credit"><strong>Creator:</strong> {{ page.creator }}</p>
{% endif %}

{{ content }}

{% if page.image %}
<div class="monster-image-container">
    <img src="{{ page.image | relative_url }}" alt="Art of {{ page.title }}">
    {% if page.image_credit %}
    <p class="image-credit">{{ page.image_credit }}</p>
    {% endif %}
</div>
{% endif %}

{% if page.layout == "statblock" %}
<div class="export-button-container">
    <button class="btn back-button" onclick="window.location.href='{{ '/monster-compendium/' | relative_url }}'">← Back to Compendium Index</button>
    <button class="btn export-json-button" onclick="exportToJSON()">Export as JSON</button>
</div>
{% endif %}

<script>
    document.addEventListener("DOMContentLoaded", function() {
        formatStatLine();
    });

    function formatStatLine() {
        const statBlock = document.querySelector('blockquote');
        if (!statBlock) return;

        // 1. Find the paragraph containing "AC" and "HP"
        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        const statP = paragraphs.find(p => p.textContent.includes('AC') && p.textContent.includes('HP'));
        
        if (!statP) return;

        let html = statP.innerHTML;

        // Regex helpers to allow either <strong> or <b> tags
        const tagRegex = "(?:<(?:strong|b)>)";
        const closeTagRegex = "(?:<\/(?:strong|b)>)";
        
        // 2. Extract AC and HP
        // We use a non-greedy match .*? up to the next bold tag
        const acRegex = new RegExp(`(${tagRegex}AC${closeTagRegex}.*?)(?=${tagRegex}HP)`, 'i');
        const hpRegex = new RegExp(`(${tagRegex}HP${closeTagRegex}.*?)(?=${tagRegex}Speed)`, 'i');
        
        const acMatch = html.match(acRegex);
        const hpMatch = html.match(hpRegex);
        
        if (acMatch && hpMatch) {
            const acHtml = acMatch[1].trim();
            const hpHtml = hpMatch[1].trim();
            
            // 3. Handling Speed and Initiative
            // We look for Speed. It stops if it hits "Initiative" OR the end of the string ($)
            let speedRegex = new RegExp(`(${tagRegex}Speed${closeTagRegex}.*?)(?=${tagRegex}Initiative|$)`, 'i');
            let speedMatch = html.match(speedRegex);
            let speedHtml = speedMatch ? speedMatch[1].trim() : "";
            
            // 4. Find Initiative
            let initHtml = "";
            let initFoundInNextP = false;
            
            // Strategy A: Look in the SAME paragraph (This covers your Awakened Tree case)
            const initTagRegex = new RegExp(`(${tagRegex}Initiative${closeTagRegex})\\s*(.*)`, 'i');
            let initMatch = html.match(initTagRegex);
            
            // Strategy B: If not found, look in the NEXT paragraph (Fallback for wrapped lines)
            if (!initMatch) {
                const nextP = statP.nextElementSibling;
                if (nextP && nextP.tagName === 'P') {
                    const nextHtml = nextP.innerHTML;
                    if (nextHtml.match(new RegExp(`^${tagRegex}Initiative`, 'i'))) {
                        initMatch = nextHtml.match(initTagRegex);
                        if (initMatch) {
                            initFoundInNextP = true;
                            nextP.remove(); // Merge it by removing the extra paragraph
                        }
                    }
                }
            }

            if (initMatch) {
                // Formatting: Change (+1) 11 -> +1 (11) if needed
                const initLabel = initMatch[1]; // <strong>Initiative</strong>
                const rawValues = initMatch[2]; // (+1) 11 OR +4 (14)
                
                // We check if it starts with a paren like "(+1)"
                const swapMatch = rawValues.match(/^\s*(\([+-]\d+\))\s*(\d+)/);
                
                if (swapMatch) {
                     const modifierWithParens = swapMatch[1]; // (+1)
                     const score = swapMatch[2];              // 11
                     const modifierClean = modifierWithParens.replace(/[()]/g, '');
                     initHtml = `${initLabel} ${modifierClean} (${score})`;
                } else {
                    // It is likely already in "+4 (14)" format or just a number
                    initHtml = `${initLabel} ${rawValues}`;
                }
            }
            
            // Safety Check: Remove any trailing Initiative text from speedHtml if the lookahead failed
            speedHtml = speedHtml.replace(new RegExp(`${tagRegex}Initiative.*`, 'i'), '').trim();

            // 5. Construct the new Grid
            const newContainer = document.createElement('div');
            newContainer.className = 'stat-grid-container';
            
            newContainer.innerHTML = `
                <div class="stat-cell-ac">${acHtml}</div>
                ${initHtml ? `<div class="stat-cell-init">${initHtml}</div>` : ''}
                <div class="stat-cell-hp">${hpHtml}</div>
                <div class="stat-cell-speed">${speedHtml}</div>
            `;

            // Replace the old paragraph with the new grid
            statP.parentNode.replaceChild(newContainer, statP);
        }
    }
</script>

<script>
    function exportToJSON() {
        const statBlock = document.querySelector('blockquote');
        if (!statBlock) {
            alert('No stat block found on this page.');
            return;
        }
        
        const extractText = (element) => element ? element.textContent.trim() : '';
        
        // --- EXTRACT BASIC INFO ---
        const nameEl = statBlock.querySelector('h2');
        const name = extractText(nameEl);
        
        const typeLineEl = statBlock.querySelector('p:first-of-type');
        const typeLine = extractText(typeLineEl);
        const typeMatch = typeLine.match(/^(\w+)\s+(\w+),\s+(.+)$/);
        
        const sizeMap = { 'Tiny': 'T', 'Small': 'S', 'Medium': 'M', 'Large': 'L', 'Huge': 'H', 'Gargantuan': 'G' };
        const size = typeMatch ? sizeMap[typeMatch[1]] || 'M' : 'M';
        const type = typeMatch ? typeMatch[2].toLowerCase() : 'unknown';
        const alignment = typeMatch ? typeMatch[3] : 'unaligned';
        
        const alignmentMap = {
            'lawful good': ['L', 'G'], 'neutral good': ['N', 'G'], 'chaotic good': ['C', 'G'],
            'lawful neutral': ['L', 'N'], 'neutral': ['N'], 'chaotic neutral': ['C', 'N'],
            'lawful evil': ['L', 'E'], 'neutral evil': ['N', 'E'], 'chaotic evil': ['C', 'E'],
            'unaligned': ['U'], 'any alignment': ['A']
        };
        const alignmentKey = alignment.toLowerCase().replace('typically ', '');
        const alignmentArr = alignmentMap[alignmentKey] || ['N'];
        
        // --- EXTRACT STATS ---
        let fullText = statBlock.innerText; 
        
        // Extract AC
        const acMatch = fullText.match(/AC\s+(\d+)/i) || fullText.match(/Armor Class\s+(\d+)/i);
        const ac = acMatch ? parseInt(acMatch[1]) : 10;
        
        // Extract HP
        const hpMatch = fullText.match(/HP\s+(\d+)/i) || fullText.match(/Hit Points\s+(\d+)/i);
        const hp = hpMatch ? parseInt(hpMatch[1]) : 1;
        
        // Extract Speed
        const speedMatch = fullText.match(/Speed\s+(.+?)(?=Initiative|STR|Str|$)/i);
        const speedText = speedMatch ? speedMatch[1].trim() : '30 ft.';
        const speed = { walk: 30 };
        
        const walkMatch = speedText.match(/(\d+)\s*ft\./);
        if (walkMatch) speed.walk = parseInt(walkMatch[1]);
        
        const flyMatch = speedText.match(/fly\s+(\d+)\s*ft\./i);
        if (flyMatch) {
            speed.fly = parseInt(flyMatch[1]);
            if (speedText.includes('hover')) {
                speed.fly = { number: speed.fly, condition: "(hover)" };
                speed.canHover = true;
            }
        }
        
        const swimMatch = speedText.match(/swim\s+(\d+)\s*ft\./i);
        if (swimMatch) speed.swim = parseInt(swimMatch[1]);
        const climbMatch = speedText.match(/climb\s+(\d+)\s*ft\./i);
        if (climbMatch) speed.climb = parseInt(climbMatch[1]);
        const burrowMatch = speedText.match(/burrow\s+(\d+)\s*ft\./i);
        if (burrowMatch) speed.burrow = parseInt(burrowMatch[1]);

        // Extract Initiative
        let initMod = 0;
        // Looks for "+X" immediately following the word Initiative
        const initMatch = fullText.match(/Initiative\s*([+-]\d+)/i);
        if (initMatch) {
            initMod = parseInt(initMatch[1]);
        }
        
        // --- ABILITIES & SAVES ---
        const table = statBlock.querySelector('table');
        const cells = table ? Array.from(table.querySelectorAll('td')) : [];
        const abilities = { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 };
        const saves = {};
        
        if (cells.length >= 12) {
            abilities.str = parseInt(extractText(cells[1])) || 10;
            abilities.dex = parseInt(extractText(cells[5])) || 10;
            abilities.con = parseInt(extractText(cells[9])) || 10;
            const strSave = extractText(cells[3]);
            const dexSave = extractText(cells[7]);
            const conSave = extractText(cells[11]);
            if (strSave && strSave !== '—') saves.str = strSave;
            if (dexSave && dexSave !== '—') saves.dex = dexSave;
            if (conSave && conSave !== '—') saves.con = conSave;
        }
        
        if (cells.length >= 24) {
            abilities.int = parseInt(extractText(cells[13])) || 10;
            abilities.wis = parseInt(extractText(cells[17])) || 10;
            abilities.cha = parseInt(extractText(cells[21])) || 10;
            const intSave = extractText(cells[15]);
            const wisSave = extractText(cells[19]);
            const chaSave = extractText(cells[23]);
            if (intSave && intSave !== '—') saves.int = intSave;
            if (wisSave && wisSave !== '—') saves.wis = wisSave;
            if (chaSave && chaSave !== '—') saves.cha = chaSave;
        }
        
        // --- OTHERS ---
        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        let skills = null, senses = [], languages = [], cr = '0', passive = 10;
        let immune = [], resist = [], vulnerable = [], conditionImmune = [];
        
        paragraphs.forEach(p => {
            const text = extractText(p);
            
            if (text.startsWith('Skills')) {
                const skillsMatch = text.match(/Skills\s+(.+)/i);
                if (skillsMatch) {
                    skills = {};
                    const skillParts = skillsMatch[1].split(',');
                    skillParts.forEach(part => {
                        const match = part.trim().match(/(\w+)\s+([+-]\d+)/);
                        if (match) skills[match[1].toLowerCase()] = match[2];
                    });
                }
            }
            if (text.startsWith('Damage Immunities')) {
                const match = text.match(/Damage Immunities\s+(.+)/i);
                if (match) immune = match[1].split(',').map(s => s.trim().toLowerCase());
            }
            if (text.startsWith('Damage Resistances')) {
                const match = text.match(/Damage Resistances\s+(.+)/i);
                if (match) resist = match[1].split(',').map(s => s.trim().toLowerCase());
            }
            if (text.startsWith('Damage Vulnerabilities')) {
                const match = text.match(/Damage Vulnerabilities\s+(.+)/i);
                if (match) vulnerable = match[1].split(',').map(s => s.trim().toLowerCase());
            }
            if (text.startsWith('Condition Immunities')) {
                const match = text.match(/Condition Immunities\s+(.+)/i);
                if (match) conditionImmune = match[1].split(',').map(s => s.trim().toLowerCase());
            }
            if (text.startsWith('Senses')) {
                const sensesMatch = text.match(/Senses\s+(.+?)(?:Passive Perception\s+(\d+))?$/i);
                if (sensesMatch) {
                    const senseText = sensesMatch[1].trim();
                    senses = senseText.split(',').map(s => s.trim()).filter(s => s);
                    if (sensesMatch[2]) passive = parseInt(sensesMatch[2]);
                }
            }
            if (text.startsWith('Languages')) {
                const langMatch = text.match(/Languages\s+(.+)/i);
                if (langMatch) languages = langMatch[1].split(',').map(s => s.trim());
            }
            if (text.includes('CR')) {
                const crMatch = text.match(/CR\s+([\d/]+)/i);
                if (crMatch) cr = crMatch[1];
            }
        });
        
        const fullData = {
            siteVersion: "1.197.0",
            _meta: {
                sources: [{
                    json: "HawthorneGuild",
                    abbreviation: "HG",
                    full: "Hawthorne Guild",
                    url: "{{ site.url }}{{ site.baseurl }}",
                    authors: ["{{ page.creator | default: 'Hawthorne Guild' }}"],
                    convertedBy: []
                }],
                dateAdded: Math.floor(Date.now() / 1000),
                dateLastModified: Math.floor(Date.now() / 1000)
            },
            monster: [{
                name: name,
                size: [size],
                type: type,
                source: "HawthorneGuild",
                alignment: alignmentArr,
                ac: [{ ac: ac }],
                hp: { average: hp },
                speed: speed,
                init: initMod,
                str: abilities.str,
                dex: abilities.dex,
                con: abilities.con,
                int: abilities.int,
                wis: abilities.wis,
                cha: abilities.cha,
                passive: passive,
                cr: cr
            }]
        };
        
        const monster = fullData.monster[0];
        if (Object.keys(saves).length > 0) monster.save = saves;
        if (skills) monster.skill = skills;
        if (immune.length > 0) monster.immune = immune;
        if (resist.length > 0) monster.resist = resist;
        if (vulnerable.length > 0) monster.vulnerable = vulnerable;
        if (conditionImmune.length > 0) monster.conditionImmune = conditionImmune;
        if (senses.length > 0) monster.senses = senses;
        if (languages.length > 0) monster.languages = languages;
        
        const dataStr = JSON.stringify(fullData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = name.toLowerCase().replace(/\s+/g, '-') + '.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
</script>