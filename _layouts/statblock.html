---
layout: default
body_class: monster-page
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<style>
    /* Grid container for the top stats line */
    .stat-grid-container {
        display: grid;
        /* "max-content" makes the columns only as wide as the text inside them */
        grid-template-columns: max-content max-content; 
        /* Aligns the columns to the left (start) */
        justify-content: start;
        /* Adds the requested spacing (approx 2 tabs width) */
        column-gap: 4em; 
        row-gap: 2px;
        margin-bottom: 1em;
    }

    /* Individual cells */
    .stat-cell-ac { grid-column: 1; }
    
    .stat-cell-init { 
        grid-column: 2; 
        text-align: left; 
    }
    
    .stat-cell-hp { grid-column: 1 / -1; } /* Spans full width */
    .stat-cell-speed { grid-column: 1 / -1; } /* Spans full width */
    
    /* Ensure bold headers look correct */
    .stat-grid-container strong, .stat-grid-container b {
        font-weight: bold;
        color: #7a200d; 
    }
</style>

{% if page.creator %}
<p class="creator-credit"><strong>Creator:</strong> {{ page.creator }}</p>
{% endif %}

{{ content }}

{% if page.image %}
<div class="monster-image-container">
    <img src="{{ page.image | relative_url }}" alt="Art of {{ page.title }}">
    {% if page.image_credit %}
    <p class="image-credit">{{ page.image_credit }}</p>
    {% endif %}
</div>
{% endif %}

{% if page.layout == "statblock" %}
<div class="export-button-container">
    <button class="btn back-button" onclick="window.location.href='{{ '/monster-compendium/' | relative_url }}'">← Back to Compendium Index</button>
    <button class="btn export-json-button" onclick="exportToJSON()">Export as JSON</button>
</div>
{% endif %}

<script>
    document.addEventListener("DOMContentLoaded", function() {
        formatStatLine();
    });

    function getStatBlockElement() {
        // IMPROVED LOGIC:
        // Instead of relying on HR tags (which might exist after the statblock),
        // we look for the specific Blockquote that contains the stats.
        
        const blocks = document.querySelectorAll('blockquote');
        
        // Convert NodeList to Array to use .find()
        return Array.from(blocks).find(block => {
            // Check if this block contains a paragraph with AC and HP markers
            const paragraphs = Array.from(block.querySelectorAll('p'));
            return paragraphs.some(p => {
                const text = p.textContent;
                return (text.includes('AC') || text.includes('Armor Class')) && 
                       (text.includes('HP') || text.includes('Hit Points'));
            });
        });
    }

    function formatStatLine() {
        const statBlock = getStatBlockElement();
        if (!statBlock) return;

        // 1. Find the paragraph containing "AC" (or "Armor Class") and "HP" (or "Hit Points")
        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        const statP = paragraphs.find(p => {
            const text = p.textContent;
            return (text.includes('AC') || text.includes('Armor Class')) && 
                   (text.includes('HP') || text.includes('Hit Points'));
        });
        
        if (!statP) return;

        let html = statP.innerHTML;

        // Regex helpers (allow <strong> or <b>)
        const tagRegex = "(?:<(?:strong|b)>)";
        const closeTagRegex = "(?:<\/(?:strong|b)>)";
        
        const acLabelPattern = "(?:AC|Armor Class)";
        const hpLabelPattern = "(?:HP|Hit Points)";
        
        // 2. Extract AC and HP using multiline match [\s\S]*? to handle line wrapping
        const acRegex = new RegExp(`(${tagRegex}${acLabelPattern}${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}${hpLabelPattern})`, 'i');
        const hpRegex = new RegExp(`(${tagRegex}${hpLabelPattern}${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}Speed)`, 'i');
        
        const acMatch = html.match(acRegex);
        const hpMatch = html.match(hpRegex);
        
        if (acMatch && hpMatch) {
            let acHtml = acMatch[1].trim();
            let hpHtml = hpMatch[1].trim();

            // Clean up trailing <br> tags if the parser added them
            acHtml = acHtml.replace(/<br\s*\/?>$/i, '');
            hpHtml = hpHtml.replace(/<br\s*\/?>$/i, '');

            // Standardize labels to short form
            acHtml = acHtml.replace(/Armor Class/, 'AC');
            hpHtml = hpHtml.replace(/Hit Points/, 'HP');
            
            // 3. Handling Speed
            let speedRegex = new RegExp(`(${tagRegex}Speed${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}Initiative|$)`, 'i');
            let speedMatch = html.match(speedRegex);
            let speedHtml = speedMatch ? speedMatch[1].trim() : "";
            speedHtml = speedHtml.replace(/<br\s*\/?>$/i, '');
            
            // 4. Find Initiative
            let initHtml = "";
            
            // Strategy A: Look in the SAME paragraph
            const initTagRegex = new RegExp(`(${tagRegex}Initiative${closeTagRegex})\\s*([\\s\\S]*)`, 'i');
            let initMatch = html.match(initTagRegex);
            
            // Strategy B: If not found, look in the NEXT paragraph
            // (Sometimes parsers break separate lines into separate paragraphs)
            if (!initMatch) {
                const nextP = statP.nextElementSibling;
                if (nextP && nextP.tagName === 'P') {
                    const nextHtml = nextP.innerHTML;
                    if (nextHtml.match(new RegExp(`^${tagRegex}Initiative`, 'i'))) {
                        initMatch = nextHtml.match(initTagRegex);
                        if (initMatch) {
                            nextP.remove(); // Merge it by removing the extra paragraph
                        }
                    }
                }
            }

            if (initMatch) {
                const initLabel = initMatch[1]; 
                const rawValues = initMatch[2];
                
                // Formatting: Change (+1) 11 -> +1 (11) if needed
                const swapMatch = rawValues.match(/^\s*(\([+-]\d+\))\s*(\d+)/);
                
                if (swapMatch) {
                     const modifierWithParens = swapMatch[1];
                     const score = swapMatch[2];
                     const modifierClean = modifierWithParens.replace(/[()]/g, '');
                     initHtml = `${initLabel} ${modifierClean} (${score})`;
                } else {
                    initHtml = `${initLabel} ${rawValues}`;
                }
            }
            
            // Cleanup Speed HTML (remove trailing Initiative text if regex leaked)
            speedHtml = speedHtml.replace(new RegExp(`${tagRegex}Initiative.*`, 'i'), '').trim();

            // 5. Construct the new Grid
            const newContainer = document.createElement('div');
            newContainer.className = 'stat-grid-container';
            
            newContainer.innerHTML = `
                <div class="stat-cell-ac">${acHtml}</div>
                ${initHtml ? `<div class="stat-cell-init">${initHtml}</div>` : ''}
                <div class="stat-cell-hp">${hpHtml}</div>
                <div class="stat-cell-speed">${speedHtml}</div>
            `;

            // Replace the old paragraph with the new grid
            statP.parentNode.replaceChild(newContainer, statP);
        }
    }
</script>

<script>
    function exportToJSON() {
        // Re-use the improved logic to find the correct block
        const statBlock = getStatBlockElement();

        if (!statBlock) {
            alert('No valid stat block found on this page.');
            return;
        }
        
        const extractText = (element) => element ? element.textContent.trim() : '';
        const fullText = statBlock.innerText;
        
        // --- EXTRACT BASIC INFO ---
        const nameEl = statBlock.querySelector('h2');
        const name = extractText(nameEl);
        
        const typeLineEl = statBlock.querySelector('p:first-of-type');
        const typeLine = extractText(typeLineEl);
        const typeMatch = typeLine.match(/^(\w+)\s+(\w+),\s+(.+)$/);
        
        const sizeMap = { 'Tiny': 'T', 'Small': 'S', 'Medium': 'M', 'Large': 'L', 'Huge': 'H', 'Gargantuan': 'G' };
        const size = typeMatch ? sizeMap[typeMatch[1]] || 'M' : 'M';
        const type = typeMatch ? typeMatch[2].toLowerCase() : 'unknown';
        
        const alignmentMap = {
            'lawful good': ['L', 'G'], 'neutral good': ['N', 'G'], 'chaotic good': ['C', 'G'],
            'lawful neutral': ['L', 'N'], 'neutral': ['N'], 'chaotic neutral': ['C', 'N'],
            'lawful evil': ['L', 'E'], 'neutral evil': ['N', 'E'], 'chaotic evil': ['C', 'E'],
            'unaligned': ['U'], 'any alignment': ['A'], 'typically neutral': ['N']
        };
        const alignmentKey = typeMatch ? typeMatch[3].toLowerCase().replace('typically ', '') : 'neutral';
        const alignmentArr = alignmentMap[alignmentKey] || ['N'];
        
        // --- EXTRACT STATS ---
        const acMatch = fullText.match(/AC\s+(\d+)/i) || fullText.match(/Armor Class\s+(\d+)/i);
        const ac = acMatch ? parseInt(acMatch[1]) : 10;
        
        const hpMatch = fullText.match(/HP\s+(\d+)/i) || fullText.match(/Hit Points\s+(\d+)/i);
        const hp = hpMatch ? parseInt(hpMatch[1]) : 1;
        
        const speedMatch = fullText.match(/Speed\s+(.+?)(?=Initiative|STR|Str|$)/i);
        const speedText = speedMatch ? speedMatch[1].trim() : '30 ft.';
        const speed = { walk: 30 };
        
        const walkMatch = speedText.match(/(\d+)\s*ft\./);
        if (walkMatch) speed.walk = parseInt(walkMatch[1]);
        
        if (speedText.match(/fly\s+(\d+)/i)) {
            const flyVal = parseInt(speedText.match(/fly\s+(\d+)/i)[1]);
            speed.fly = speedText.includes('hover') ? { number: flyVal, condition: "(hover)" } : flyVal;
            if (speedText.includes('hover')) speed.canHover = true;
        }
        if (speedText.match(/swim\s+(\d+)/i)) speed.swim = parseInt(speedText.match(/swim\s+(\d+)/i)[1]);
        if (speedText.match(/climb\s+(\d+)/i)) speed.climb = parseInt(speedText.match(/climb\s+(\d+)/i)[1]);
        if (speedText.match(/burrow\s+(\d+)/i)) speed.burrow = parseInt(speedText.match(/burrow\s+(\d+)/i)[1]);

        let initMod = 0;
        const initMatch = fullText.match(/Initiative\s*([+-]\d+)/i);
        if (initMatch) initMod = parseInt(initMatch[1]);
        
        // --- ABILITIES ---
        const table = statBlock.querySelector('table');
        const cells = table ? Array.from(table.querySelectorAll('td')) : [];
        const abilities = { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 };
        const saves = {};
        
        const findCellIndex = (text) => cells.findIndex(c => c.textContent.includes(text));
        
        ['Str', 'Dex', 'Con', 'Int', 'Wis', 'Cha'].forEach(ab => {
            const idx = findCellIndex(ab);
            if (idx !== -1 && cells.length > idx + 1) {
                const key = ab.toLowerCase();
                abilities[key] = parseInt(extractText(cells[idx + 1])) || 10;
                const saveVal = extractText(cells[idx + 3]);
                if (saveVal && saveVal !== '—') saves[key] = saveVal;
            }
        });
        
        // --- OTHERS ---
        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        let skills = null, senses = [], languages = [], cr = '0', passive = 10;
        let immune = [], resist = [], vulnerable = [], conditionImmune = [];
        
        paragraphs.forEach(p => {
            const text = extractText(p);
            
            if (text.startsWith('Skills')) {
                const skillsMatch = text.match(/Skills\s+(.+)/i);
                if (skillsMatch) {
                    skills = {};
                    skillsMatch[1].split(',').forEach(part => {
                        const match = part.trim().match(/(\w+)\s+([+-]\d+)/);
                        if (match) skills[match[1].toLowerCase()] = match[2];
                    });
                }
            }
            if (text.startsWith('Damage Immunities')) immune = text.replace('Damage Immunities ', '').split(',').map(s=>s.trim().toLowerCase());
            if (text.startsWith('Damage Resistances')) resist = text.replace('Damage Resistances ', '').split(',').map(s=>s.trim().toLowerCase());
            if (text.startsWith('Damage Vulnerabilities')) vulnerable = text.replace('Damage Vulnerabilities ', '').split(',').map(s=>s.trim().toLowerCase());
            if (text.startsWith('Condition Immunities')) conditionImmune = text.replace('Condition Immunities ', '').split(',').map(s=>s.trim().toLowerCase());
            
            if (text.startsWith('Senses')) {
                const sensesMatch = text.match(/Senses\s+(.+?)(?:Passive Perception\s+(\d+))?$/i);
                if (sensesMatch) {
                    senses = sensesMatch[1].split(',').map(s => s.trim()).filter(s => s);
                    if (sensesMatch[2]) passive = parseInt(sensesMatch[2]);
                }
            }
            if (text.startsWith('Languages')) languages = text.replace('Languages ', '').split(',').map(s=>s.trim());
            if (text.match(/(?:CR|Challenge)\s+([\d/]+)/i)) cr = text.match(/(?:CR|Challenge)\s+([\d/]+)/i)[1];
        });
        
        const fullData = {
            siteVersion: "1.197.0",
            _meta: {
                sources: [{
                    json: "HawthorneGuild",
                    abbreviation: "HG",
                    full: "Hawthorne Guild",
                    url: "{{ site.url }}{{ site.baseurl }}",
                    authors: ["{{ page.creator | default: 'Hawthorne Guild' }}"],
                    convertedBy: []
                }],
                dateAdded: Math.floor(Date.now() / 1000),
                dateLastModified: Math.floor(Date.now() / 1000)
            },
            monster: [{
                name: name,
                size: [size],
                type: type,
                source: "HawthorneGuild",
                alignment: alignmentArr,
                ac: [{ ac: ac }],
                hp: { average: hp },
                speed: speed,
                init: initMod,
                str: abilities.str,
                dex: abilities.dex,
                con: abilities.con,
                int: abilities.int,
                wis: abilities.wis,
                cha: abilities.cha,
                passive: passive,
                cr: cr
            }]
        };
        
        const monster = fullData.monster[0];
        if (Object.keys(saves).length > 0) monster.save = saves;
        if (skills) monster.skill = skills;
        if (immune.length > 0) monster.immune = immune;
        if (resist.length > 0) monster.resist = resist;
        if (vulnerable.length > 0) monster.vulnerable = vulnerable;
        if (conditionImmune.length > 0) monster.conditionImmune = conditionImmune;
        if (senses.length > 0) monster.senses = senses;
        if (languages.length > 0) monster.languages = languages;
        
        const dataStr = JSON.stringify(fullData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = name.toLowerCase().replace(/\s+/g, '-') + '.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
</script>