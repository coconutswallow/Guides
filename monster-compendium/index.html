---
layout: default
title: Hawthorne Monster Compendium
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<h2>Hawthorne Monsters Compendium</h2>
<p>The monsters in this compendium have been created by various members of the community of the Hawthorne Dungeons & Dragons Guild. The credits are listed on the footer of the monster pages.</p>

<p>If you are a DM and would like to submit a monster that can be used by DMs across the server, <a href="{{ site.baseurl }}/monster-compendium/generator/">visit the Creator Studio.</a> </p>

<h3>Filter Monsters</h3>
<p>Use the filter below to quickly find monsters by name, type, size and CR.</p>

<div class="filter-container">
  <div class="filter-group">
    <label for="name-search">Name:</label>
    <input type="text" id="name-search" class="filter-input" placeholder="Search by name...">
  </div>
  <div class="filter-group">
    <label for="type-filter">Type:</label>
    <select id="type-filter" class="filter-select">
      <option value="">All Types</option>
    </select>
  </div>
  
  <div class="filter-group">
    <label for="cr-from">CR From:</label>
    <input type="number" id="cr-from" class="filter-input" placeholder="Min" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="cr-to">CR To:</label>
    <input type="number" id="cr-to" class="filter-input" placeholder="Max" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="size-filter">Size:</label>
    <select id="size-filter" class="filter-select">
      <option value="">All Sizes</option>
    </select>
  </div>
  
  <button id="reset-filters" class="reset-button">Reset Filters</button>
</div>

<div id="monster-count" class="monster-count">Loading database...</div>

<div id="monster-list-container"></div>

<a href="https://www.artstation.com/mandryk" style="display:block; margin-top:40px; font-size:0.8em; color:#666;">Background Image: Goblin Chaos by David Mandryk</a>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="{{ '/assets/js/auth-manager.js' | relative_url }}"></script>

<style>
/* ... (Keep your existing CSS exactly as provided in the source file) ... */
/* ... I have omitted repeating the CSS block to save space, insert here ... */
.filter-container {
  background: #FDF1DC;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  padding: 1.5em;
  margin: 2em 0;
  display: flex;
  flex-wrap: wrap;
  gap: 1em;
  align-items: flex-end;
}
.filter-group {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  flex: 1;
  min-width: 150px;
}
.filter-group label {
  font-family: var(--font-header);
  font-weight: 700;
  color: var(--color-primary);
  text-transform: uppercase;
  font-size: 0.9em;
  letter-spacing: 0.5px;
}
.filter-select {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  cursor: pointer;
}
.filter-select:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}
.filter-input {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  width: 100%;
}
.filter-input:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}
.filter-input::placeholder {
  color: #999;
  font-style: italic;
}
.reset-button {
  padding: 0.5em 1.5em;
  background: var(--color-primary);
  color: #FDF1DC;
  border: none;
  border-radius: 0px;
  font-family: var(--font-header);
  font-size: 0.9em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background 0.2s;
  height: fit-content;
}
.reset-button:hover {
  background: var(--color-secondary);
}
.monster-count {
  font-family: var(--font-body);
  font-style: italic;
  color:var(--color-primary);
  margin: 1em 0;
  font-size: 0.95em;
}
.category-section {
  margin-bottom: 2em;
}
.category-section.hidden {
  display: none;
}
.category-toggle {
  background: none;
  border: none;
  font-family: var(--font-header);
  font-size: 1.0em;
  font-weight: 700;
  color: var( --color-secondary);
  cursor: pointer;
  padding: 0.5em 0;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 0.5em;
  transition: color 0.2s;
}
.category-toggle:hover {
  color: var(--color-secondary);
}
.toggle-icon {
  display: inline-block;
  transition: transform 0.3s ease;
  font-size: 0.8em;
}
.category-toggle[aria-expanded="false"] .toggle-icon {
  transform: rotate(-90deg);
}
.category-section[aria-expanded="false"] .monster-list {
  display: none;
}
.monster-list .monster-card {
  display: flex;
  gap: 1em;
  align-items: center;
  margin-bottom: 15px; /* Added spacing */
}
.monster-list .monster-card-image {
  flex-shrink: 0;
  width: 80px !important;
  height: 80px !important;
  overflow: hidden;
  border-radius: 0px;
  border: 2px solid var(--color-primary);
}
.monster-list .monster-card-image img {
  width: 100% !important;
  height: 100% !important;
  max-width: 80px !important;
  max-height: 80px !important;
  object-fit: cover;
  display: block;
}
.monster-list .monster-card-content {
  flex: 1;
  min-width: 0; 
}
.monster-card.hidden {
  display: none;
}
@media (max-width: 768px) {
  .filter-container {
    flex-direction: column;
    align-items: stretch;
  }
  .filter-group {
    min-width: 100%;
  }
  .reset-button {
    width: 100%;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', async function() {
    // 1. Initialize Supabase (Uses config from auth-manager.js)
    if (typeof supabase === 'undefined') {
        console.error("Supabase SDK not loaded");
        document.getElementById('monster-count').textContent = "Error loading database library.";
        return;
    }
    // We assume AUTH_MANAGER or SUPABASE_CONFIG was loaded. 
    // Re-creating client here manually to ensure no dependency race conditions 
    // with auth-manager's class structure for this simple public fetch.
    const SUPABASE_URL = 'https://iepqxczcyvrxcbyeiscc.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImllcHF4Y3pjeXZyeGNieWVpc2NjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQzNjU2MDEsImV4cCI6MjA3OTk0MTYwMX0.9fK4TppNy7IekO3n4Uwd37dbqMQ7KRhFkex_P_JSeVA';
    const db = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    const monsterListContainer = document.getElementById('monster-list-container');
    const monsterCount = document.getElementById('monster-count');

    // 2. Fetch "Approved" Monsters
    // We fetch the JSON content, title, and metadata
    const { data: monsters, error } = await db
        .from('monsters')
        .select('*')
        .eq('status', 'approved')
        .order('title', { ascending: true });

    if (error) {
        monsterCount.textContent = "Error fetching monsters: " + error.message;
        return;
    }

    if (!monsters || monsters.length === 0) {
        monsterCount.textContent = "No approved monsters found in the compendium.";
        return;
    }

    // 3. Group by Category
    const grouped = {};
    monsters.forEach(row => {
        // The detailed stats are in row.content, but we use row.title/row.content.category
        const monster = row.content; // The JSON blob
        // Ensure core fields exist
        const cat = monster.category || 'Uncategorized';
        if (!grouped[cat]) grouped[cat] = [];
        grouped[cat].push({
            id: row.id,
            title: monster.title,
            cr: monster.cr,
            type: monster.type,
            size: monster.size,
            image: monster.image,
            // We link to a viewer page passing the ID
            url: `{{ site.baseurl }}/monster-compendium/view/?id=${row.id}`
        });
    });

    // 4. Render HTML Structure (Replicating the Liquid Template logic)
    const sortedCategories = Object.keys(grouped).sort();
    
    sortedCategories.forEach(category => {
        const items = grouped[category];
        
        // Create Section
        const section = document.createElement('div');
        section.className = 'category-section';
        section.dataset.category = category;
        section.setAttribute('aria-expanded', 'true');

        // Header
        section.innerHTML = `
            <h2 class="category-title">
                <button class="category-toggle" aria-expanded="true">
                    <span class="toggle-icon">â–¼</span>
                    ${category}
                </button>
            </h2>
            <div class="monster-list"></div>
        `;

        const listContainer = section.querySelector('.monster-list');

        // Cards
        items.forEach(m => {
            const card = document.createElement('div');
            card.className = 'monster-card';
            card.dataset.cr = m.cr;
            card.dataset.type = m.type;
            card.dataset.size = m.size;

            let imageHtml = '';
            if (m.image) {
                imageHtml = `
                <div class="monster-card-image">
                    <img src="${m.image}" alt="${m.title}">
                </div>`;
            }

            card.innerHTML = `
                ${imageHtml}
                <div class="monster-card-content">
                    <h3><a href="${m.url}">${m.title}</a></h3>
                    <p class="monster-cr">CR ${m.cr}</p>
                    <p class="monster-type">${m.type}</p>
                </div>
            `;
            listContainer.appendChild(card);
        });

        monsterListContainer.appendChild(section);
    });

    // 5. Initialize Filter Logic (Now that DOM exists)
    initFilters();
});

// =========================================================
//  EXISTING FILTER LOGIC (Wrapped in function for async calling)
// =========================================================
function initFilters() {
    const nameSearchInput = document.getElementById('name-search');
    const typeFilter = document.getElementById('type-filter');
    const crFromInput = document.getElementById('cr-from');
    const crToInput = document.getElementById('cr-to');
    const sizeFilter = document.getElementById('size-filter');
    const resetButton = document.getElementById('reset-filters');
    const monsterCards = document.querySelectorAll('.monster-card');
    const categorySections = document.querySelectorAll('.category-section');
    const monsterCount = document.getElementById('monster-count');

    // Helper: Parse CR
    function parseCR(crString) {
        if (!crString) return 9999;
        if (String(crString).includes('/')) {
            const parts = crString.split('/');
            return parseFloat(parts[0]) / parseFloat(parts[1]);
        }
        return parseFloat(crString);
    }

    // Populate Dropdowns
    const types = new Set();
    const sizes = new Set();
    
    monsterCards.forEach(card => {
        if (card.dataset.type) types.add(card.dataset.type);
        if (card.dataset.size) sizes.add(card.dataset.size);
    });

    // Toggle Functionality
    document.querySelectorAll('.category-toggle').forEach(toggle => {
        toggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            const section = this.closest('.category-section');
            section.setAttribute('aria-expanded', !isExpanded);
        });
    });

    // Populate Type Select
    Array.from(types).sort().forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        typeFilter.appendChild(option);
    });

    // Populate Size Select
    const sizeOrder = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
    Array.from(sizes).sort((a, b) => sizeOrder.indexOf(a) - sizeOrder.indexOf(b))
        .forEach(size => {
            const option = document.createElement('option');
            option.value = size;
            option.textContent = size;
            sizeFilter.appendChild(option);
        });

    // Filter Logic
    function filterMonsters() {
        const selectedType = typeFilter.value;
        const crFrom = crFromInput.value ? Number(crFromInput.value) : null; 
        const crTo = crToInput.value ? Number(crToInput.value) : null;
        const selectedSize = sizeFilter.value;
        const selectedName = nameSearchInput.value.toLowerCase().trim();
        
        let visibleCount = 0;
        
        monsterCards.forEach(card => {
            const cardType = card.dataset.type;
            const cardCR = parseCR(card.dataset.cr);
            const cardSize = card.dataset.size;
            const cardName = card.querySelector('h3 a').textContent.toLowerCase();
            
            const typeMatch = !selectedType || cardType === selectedType;
            const sizeMatch = !selectedSize || cardSize === selectedSize;
            const nameMatch = !selectedName || cardName.includes(selectedName);
            
            let crMatch = true;
            if (crFrom !== null && cardCR < crFrom) crMatch = false;
            if (crTo !== null && cardCR > crTo) crMatch = false;
            
            if (typeMatch && crMatch && sizeMatch && nameMatch) {
                card.classList.remove('hidden');
                visibleCount++;
            } else {
                card.classList.add('hidden');
            }
        });
        
        // Sorting and Cleanup
        categorySections.forEach(section => {
            const monsterList = section.querySelector('.monster-list');
            const allCards = Array.from(monsterList.querySelectorAll('.monster-card'));
            
            allCards.sort((a, b) => {
                const aIsHidden = a.classList.contains('hidden');
                const bIsHidden = b.classList.contains('hidden');
                if (aIsHidden && !bIsHidden) return 1;
                if (!aIsHidden && bIsHidden) return -1;
                return parseCR(a.dataset.cr) - parseCR(b.dataset.cr);
            });
            
            allCards.forEach(card => monsterList.appendChild(card));
            
            const visibleInSection = section.querySelectorAll('.monster-card:not(.hidden)');
            if (visibleInSection.length === 0) section.classList.add('hidden');
            else section.classList.remove('hidden');
        });
        
        monsterCount.textContent = `Showing ${visibleCount} of ${monsterCards.length} monsters`;
    }

    function resetFilters() {
        typeFilter.value = '';
        crFromInput.value = '';
        crToInput.value = '';
        sizeFilter.value = '';
        nameSearchInput.value = '';
        filterMonsters();
    }

    typeFilter.addEventListener('change', filterMonsters);
    crFromInput.addEventListener('input', filterMonsters);
    crToInput.addEventListener('input', filterMonsters);
    sizeFilter.addEventListener('change', filterMonsters);
    nameSearchInput.addEventListener('input', filterMonsters);
    resetButton.addEventListener('click', resetFilters);
    
    // Initial Run
    filterMonsters();
}
</script>