---
layout: default
title: Hawthorne Monster Compendium
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<h2>Hawthorne Monsters Compendium</h2>
<p>The monsters in this compendium have been created by various members of the community of the Hawthorne Dungeons & Dragons Guild.</p>

<p>If you are a DM and would like to submit a monster that can be used by DMs across the server, <a href="{{ site.baseurl }}/monster-compendium/generator/">use the Monster Generator here.</a></p>

<h3>Filter Monsters</h3>
<p>Use the filter below to quickly find monsters by name, type, size and CR.</p>

<div class="filter-container">
  <div class="filter-group">
    <label for="name-search">Name:</label>
    <input type="text" id="name-search" class="filter-input" placeholder="Search by name...">
  </div>
  <div class="filter-group">
    <label for="type-filter">Type:</label>
    <select id="type-filter" class="filter-select">
      <option value="">All Types</option>
      </select>
  </div>
  
  <div class="filter-group">
    <label for="cr-from">CR From:</label>
    <input type="number" id="cr-from" class="filter-input" placeholder="Min" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="cr-to">CR To:</label>
    <input type="number" id="cr-to" class="filter-input" placeholder="Max" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="size-filter">Size:</label>
    <select id="size-filter" class="filter-select">
      <option value="">All Sizes</option>
      </select>
  </div>
  
  <button id="reset-filters" class="reset-button">Reset Filters</button>
</div>

<div id="monster-count" class="monster-count">Loading Compendium...</div>

<div id="dynamic-monster-list"></div>

<a href="https://www.artstation.com/mandryk" style="display:block; margin-top: 40px; font-size: 0.8em; color: #666;">Background Image: Goblin Chaos by David Mandryk</a>

<style>
/* ... [Keep all your existing CSS from the previous file] ... */
/* Add this for the loading state */
.monster-count { font-weight: bold; color: var(--color-primary); }
</style>

<script>
  // --- CONFIGURATION ---
  // Replace with your actual project details
  const SUPABASE_URL = 'https://iepqxczcyvrxcbyeiscc.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImllcHF4Y3pjeXZyeGNieWVpc2NjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQzNjU2MDEsImV4cCI6MjA3OTk0MTYwMX0.9fK4TppNy7IekO3n4Uwd37dbqMQ7KRhFkex_P_JSeVA';
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  document.addEventListener('DOMContentLoaded', async function() {
    
    // 1. Fetch Data
    const container = document.getElementById('dynamic-monster-list');
    const countLabel = document.getElementById('monster-count');

    try {
      // Fetch only Approved monsters
      // We explicitly select columns to minimize payload size
      const { data: monsters, error } = await supabase
        .from('monsters')
        .select('id, title, cr, type, data') 
        .eq('status', 'approved')
        .order('title');

      if (error) throw error;

      if (!monsters || monsters.length === 0) {
        container.innerHTML = '<p>No monsters found in the compendium yet.</p>';
        countLabel.textContent = '';
        return;
      }

      // 2. Group by Category
      // We extract category from the JSONB 'data' column
      const grouped = monsters.reduce((acc, monster) => {
        const cat = monster.data.category || 'Uncategorized';
        if (!acc[cat]) acc[cat] = [];
        acc[cat].push(monster);
        return acc;
      }, {});

      // Sort categories (optional, but nice)
      const sortedCategories = Object.keys(grouped).sort();

      // 3. Render HTML
      let html = '';

      sortedCategories.forEach(category => {
        // Generate Cards HTML
        const cardsHtml = grouped[category].map(m => {
            // Extract details
            const size = m.data.size || 'Medium';
            const image = m.data.image || ''; // Optional image
            const thumbUrl = image ? `https://wsrv.nl/?url=${encodeURIComponent(image)}&w=80&h=80&output=webp` : '';
            
            // Note: We point to viewer.html with the ID
            return `
            <div class="monster-card" 
                 data-cr="${m.cr}" 
                 data-type="${m.type}" 
                 data-size="${size}">
              
              ${ image ? `
              <div class="monster-card-image">
                <img src="${thumbUrl}" alt="${m.title}" loading="lazy" onerror="this.style.display='none'">
              </div>` : '' }
              
              <div class="monster-card-content">
                <h3><a href="/monster-compendium/monster-viewer.html?id=${m.id}">${m.title}</a></h3>
                <p class="monster-cr">CR ${m.cr}</p>
                <p class="monster-type">${m.type}</p>
              </div>
            </div>
            `;
        }).join('');

        // Generate Category Wrapper HTML
        html += `
          <div class="category-section" data-category="${category}" aria-expanded="true">
            <h2 class="category-title">
              <button class="category-toggle" aria-expanded="true">
                <span class="toggle-icon">â–¼</span>
                ${category}
              </button>
            </h2>
            <div class="monster-list">
              ${cardsHtml}
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
      countLabel.textContent = `Showing ${monsters.length} monsters`;

      // 4. Initialize Filters & UI
      initializeFilters();
      initializeToggles();

    } catch (err) {
      console.error('Error loading compendium:', err);
      container.innerHTML = '<p class="error">Failed to load monsters. Please try again later.</p>';
    }
  });

  /* --- UI INITIALIZATION HELPERS --- */

  function initializeToggles() {
    document.querySelectorAll('.category-toggle').forEach(toggle => {
      toggle.addEventListener('click', function() {
        const isExpanded = this.getAttribute('aria-expanded') === 'true';
        this.setAttribute('aria-expanded', !isExpanded);
        const section = this.closest('.category-section');
        section.setAttribute('aria-expanded', !isExpanded);
      });
    });
  }

  function initializeFilters() {
    const nameInput = document.getElementById('name-search');
    const typeSelect = document.getElementById('type-filter');
    const sizeSelect = document.getElementById('size-filter');
    const crFrom = document.getElementById('cr-from');
    const crTo = document.getElementById('cr-to');
    const resetBtn = document.getElementById('reset-filters');
    const cards = document.querySelectorAll('.monster-card');
    const sections = document.querySelectorAll('.category-section');
    const countLabel = document.getElementById('monster-count');

    // Populate Dropdowns
    const types = new Set();
    const sizes = new Set();
    cards.forEach(c => {
        types.add(c.dataset.type);
        sizes.add(c.dataset.size);
    });

    Array.from(types).sort().forEach(t => {
        typeSelect.add(new Option(t, t));
    });

    const sizeOrder = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
    Array.from(sizes).sort((a,b) => sizeOrder.indexOf(a) - sizeOrder.indexOf(b)).forEach(s => {
        sizeSelect.add(new Option(s, s));
    });

    // Helper: Parse CR
    const parseCR = (str) => {
        if (!str) return 999;
        if (str.includes('/')) {
            const [n, d] = str.split('/');
            return parseFloat(n) / parseFloat(d);
        }
        return parseFloat(str);
    };

    // Main Filter Logic
    const runFilter = () => {
        const sName = nameInput.value.toLowerCase().trim();
        const sType = typeSelect.value;
        const sSize = sizeSelect.value;
        const minCr = crFrom.value ? parseFloat(crFrom.value) : -1;
        const maxCr = crTo.value ? parseFloat(crTo.value) : 999;

        let visibleCount = 0;

        cards.forEach(card => {
            const cName = card.querySelector('h3').textContent.toLowerCase();
            const cType = card.dataset.type;
            const cSize = card.dataset.size;
            const cCr = parseCR(card.dataset.cr);

            let visible = true;
            if (sName && !cName.includes(sName)) visible = false;
            if (sType && cType !== sType) visible = false;
            if (sSize && cSize !== sSize) visible = false;
            if (cCr < minCr || cCr > maxCr) visible = false;

            if (visible) {
                card.classList.remove('hidden');
                visibleCount++;
            } else {
                card.classList.add('hidden');
            }
        });

        // Hide empty categories
        sections.forEach(sec => {
            const hasVisible = sec.querySelectorAll('.monster-card:not(.hidden)').length > 0;
            if(hasVisible) sec.classList.remove('hidden');
            else sec.classList.add('hidden');
        });

        countLabel.textContent = `Showing ${visibleCount} monsters`;
    };

    // Attach Listeners
    [nameInput, typeSelect, sizeSelect, crFrom, crTo].forEach(el => el.addEventListener('input', runFilter));
    
    resetBtn.addEventListener('click', () => {
        nameInput.value = '';
        typeSelect.value = '';
        sizeSelect.value = '';
        crFrom.value = '';
        crTo.value = '';
        runFilter();
    });
  }
</script>